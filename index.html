<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>MUHAMMED ALƒ∞ AKKAYA</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    
    <style>
        body {
            background: #1a1a1a;
            background-image: linear-gradient(rgba(0, 0, 0, 0.6), rgba(0, 0, 0, 0.6)), url("unnamed.jpg");
            background-size: cover; background-position: center; background-repeat: no-repeat;
            background-attachment: fixed; margin: 0; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex; align-items: center; justify-content: center;
            height: 100vh; overflow: hidden; touch-action: none;
        }

        /* Men√º Butonu - Sol √úst K√∂≈üede Sabit */
        .open-btn {
            position: fixed; top: 20px; left: 20px; font-size: 16px; cursor: pointer;
            background: #2c3e50; color: white; padding: 10px 20px; border: 2px solid #fff; 
            z-index: 9999; border-radius: 5px;
        }

        /* Buton Konteyner - Ortada Sabit */
        .button-container {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            display: flex; flex-direction: column; gap: 20px; z-index: 9000;
        }

        .main-btn {
            padding: 20px 50px; color: white; border: none;
            border-radius: 50px; cursor: pointer; font-size: 24px; font-weight: bold;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5); transition: transform 0.2s;
            min-width: 280px; text-align: center;
        }
        #startBtn { background: #e74c3c; }
        #snakeBtn { background: #2ecc71; }
        .main-btn:active { transform: scale(0.95); }

        .sidebar {
            height: 100%; width: 0; position: fixed; z-index: 10001; top: 0; left: 0;
            background-color: rgba(0, 0, 0, 0.95); overflow-x: hidden; transition: 0.5s; padding-top: 60px;
        }
        .sidebar a { padding: 15px 32px; text-decoration: none; font-size: 20px; color: #bbb; display: block; }
        .sidebar .close-btn { position: absolute; top: 10px; right: 25px; font-size: 36px; color: white; cursor: pointer; }

        .game-wrapper {
            display: none; position: fixed; top: 50%; left: 50%;
            transform: translate(-50%, -50%); z-index: 9500;
        }

        .game-header {
            display: flex; justify-content: space-between; align-items: center;
            background: #2c3e50; padding: 10px; border-radius: 10px 10px 0 0;
            border: 2px solid #2ecc71; color: white; font-family: monospace;
        }

        .game-container {
            width: 90vw; max-width: 360px; height: 70vh; max-height: 550px;
            background: #fdfdfd; border: 4px solid #2ecc71; position: relative;
            overflow: hidden; border-radius: 0 0 10px 10px;
        }

        .close-game {
            background: #c0392b; color: white; padding: 5px 12px;
            cursor: pointer; font-weight: bold; border-radius: 5px; font-size: 12px; border: none;
        }

        .game-over-overlay {
            display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9); flex-direction: column; align-items: center;
            justify-content: center; z-index: 11000; text-align: center;
        }

        /* Yƒ±lan Kontrolleri */
        .mobile-controls {
            display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px;
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
        }
        .ctrl-btn {
            width: 50px; height: 50px; background: rgba(0,0,0,0.1);
            border: 2px solid #333; color: #333; border-radius: 10px;
            display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 20px;
        }
    </style>
</head>
<body>

    <button class="open-btn" onclick="toggleNav()">‚ò∞ MEN√ú</button>

    <div id="mySidebar" class="sidebar">
        <div class="close-btn" onclick="toggleNav()">&times;</div>
        <a href="#" onclick="toggleNav()">ANASAYFA</a>
        <a href="https://www.linkedin.com" target="_blank">ƒ∞LETƒ∞≈ûƒ∞M</a>
    </div>
    
    <div class="button-container" id="menuButtons">
        <button id="startBtn" class="main-btn" onclick="openGame()">MEYVE OYUNU</button>
        <button id="snakeBtn" class="main-btn" onclick="openSnakeGame()">YILAN OYUNU</button>
    </div>

    <div id="gameWrapper" class="game-wrapper">
        <div id="gameHeader" class="game-header">
            <div>SKOR: <span id="scoreVal">0</span><br>REKOR: <span id="highScore">0</span></div>
            <div style="text-align: center;">SIRADAKƒ∞<br><span id="nextEmoji" style="font-size: 24px;">üçì</span></div>
            <button class="close-game" onclick="closeGame()">KAPAT X</button>
        </div>
        <div id="gameContainer" class="game-container">
            <div style="position: absolute; top: 60px; left: 0; width: 100%; height: 2px; background: rgba(255, 0, 0, 0.4); z-index: 10; pointer-events: none; border-top: 1px dashed red;"></div>
            <div id="gameOverOverlay" class="game-over-overlay">
                <h2 style="color: #e74c3c; font-size: 36px; margin-bottom: 20px;">OYUN Bƒ∞TTƒ∞</h2>
                <p style="color:white">Skorun: <span id="finalScore">0</span></p>
                <button class="close-game" style="font-size: 16px; padding: 15px 30px; background: #2ecc71;" onclick="openGame()">TEKRAR DENE</button>
            </div>
            <div id="gameCanvas" style="width:100%; height:100%;"></div>
        </div>
    </div>

    <div id="snakeWrapper" class="game-wrapper">
        <div class="game-header" style="background: #333; border-color: #555;">
            <div style="color: white;">YILAN SKOR: <span id="snakeScore">0</span></div>
            <button class="close-game" onclick="closeSnakeGame()">KAPAT X</button>
        </div>
        <div class="game-container" style="background: white; border-color: #555;">
            <canvas id="snakeCanvas" style="background: white; width: 100%; height: 100%;"></canvas>
            <div id="snakeGameOver" class="game-over-overlay">
                <h2 style="color: white; font-size: 32px;">√ñLD√úN!</h2>
                <button class="close-game" style="font-size: 16px; padding: 10px 20px; background: #2ecc71;" onclick="openSnakeGame()">TEKRAR DENE</button>
            </div>
            <div class="mobile-controls">
                <div></div><div class="ctrl-btn" onclick="changeDir('UP')">‚Üë</div><div></div>
                <div class="ctrl-btn" onclick="changeDir('LEFT')">‚Üê</div><div class="ctrl-btn" onclick="changeDir('DOWN')">‚Üì</div><div class="ctrl-btn" onclick="changeDir('RIGHT')">‚Üí</div>
            </div>
        </div>
    </div>

    <script>
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        function playPop() {
            try {
                if (audioCtx.state === 'suspended') audioCtx.resume();
                const osc = audioCtx.createOscillator();
                const g = audioCtx.createGain();
                osc.type = 'sine';
                osc.frequency.setValueAtTime(400, audioCtx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
                g.gain.setValueAtTime(0.1, audioCtx.currentTime);
                g.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
                osc.connect(g); g.connect(audioCtx.destination);
                osc.start(); osc.stop(audioCtx.currentTime + 0.1);
            } catch(e) {}
        }

        function toggleNav() {
            var s = document.getElementById("mySidebar");
            s.style.width = (s.style.width === "250px") ? "0" : "250px";
        }

        // --- MEYVE OYUNU ---
        let engine, render, runner, score = 0, nextFruitIdx = 0, isGameOver = false, canDrop = true;
        const { Engine, Render, Runner, Bodies, Composite, Events } = Matter;

        const FRUITS = [
            { r: 15, label: 'üçì', score: 2, color: '#ff4d4d' },
            { r: 22, label: 'üçá', score: 4, color: '#a29bfe' },
            { r: 30, label: 'üçä', score: 6, color: '#fdcb6e' },
            { r: 40, label: 'üçé', score: 10, color: '#ff7675' },
            { r: 52, label: 'üçë', score: 15, color: '#fab1a0' },
            { r: 65, label: 'üçâ', score: 25, color: '#2ecc71' },
            { r: 85, label: 'üçç', score: 50, color: '#f1c40f' }
        ];

        function updateNextFruit() {
            nextFruitIdx = Math.floor(Math.random() * 3);
            document.getElementById("nextEmoji").innerText = FRUITS[nextFruitIdx].label;
        }

        function openGame() {
            if (render) { Render.stop(render); if(runner) Runner.stop(runner); Engine.clear(engine); if(render.canvas) render.canvas.remove(); }
            score = 0; isGameOver = false; canDrop = true;
            document.getElementById("scoreVal").innerText = "0";
            document.getElementById("highScore").innerText = localStorage.getItem('highScore') || 0;
            document.getElementById("gameWrapper").style.display = "block";
            document.getElementById("gameOverOverlay").style.display = "none";
            document.getElementById("menuButtons").style.display = "none";
            updateNextFruit();
            initMeyveOyunu();
        }

        function closeGame() {
            document.getElementById("gameWrapper").style.display = "none";
            document.getElementById("menuButtons").style.display = "flex";
            if (render) { Render.stop(render); if(runner) Runner.stop(runner); Engine.clear(engine); if(render.canvas) render.canvas.remove(); render = null; }
        }

        function initMeyveOyunu() {
            const container = document.getElementById('gameCanvas');
            engine = Engine.create();
            engine.world.gravity.y = 1.2;
            render = Render.create({
                element: container, engine: engine,
                options: { width: container.clientWidth, height: container.clientHeight, wireframes: false, background: 'transparent' }
            });
            const ground = Bodies.rectangle(180, container.clientHeight + 10, 800, 40, { isStatic: true, label: 'wall', render: { fillStyle: '#2c3e50' } });
            const left = Bodies.rectangle(-10, 250, 25, 1000, { isStatic: true, label: 'wall' });
            const right = Bodies.rectangle(container.clientWidth + 10, 250, 25, 1000, { isStatic: true, label: 'wall' });
            Composite.add(engine.world, [ground, left, right]);

            function drop(e) {
                if(isGameOver || !canDrop) return;
                canDrop = false;
                const rect = render.canvas.getBoundingClientRect();
                const clientX = (e.touches ? e.touches[0].clientX : e.clientX);
                const x = Math.max(25, Math.min(render.canvas.width - 25, clientX - rect.left));
                const f = FRUITS[nextFruitIdx];
                const fruit = Bodies.circle(x, 25, f.r, { label: f.label, restitution: 0.3, friction: 0.1, isFirstDrop: true, render: { fillStyle: f.color } });
                Composite.add(engine.world, fruit);
                setTimeout(() => { canDrop = true; updateNextFruit(); }, 600);
            }
            render.canvas.addEventListener('mousedown', drop);
            render.canvas.addEventListener('touchstart', (e) => { e.preventDefault(); drop(e); }, {passive: false});

            Events.on(engine, 'collisionStart', (event) => {
                event.pairs.forEach((pair) => {
                    const { bodyA, bodyB } = pair;
                    if (bodyA.label === bodyB.label && bodyA.label !== 'wall' && !bodyA.isMerging && !bodyB.isMerging) {
                        const idx = FRUITS.findIndex(f => f.label === bodyA.label);
                        if (idx !== -1 && idx < FRUITS.length - 1) {
                            bodyA.isMerging = true; bodyB.isMerging = true;
                            playPop();
                            const next = FRUITS[idx + 1];
                            score += next.score;
                            document.getElementById("scoreVal").innerText = score;
                            const upgraded = Bodies.circle((bodyA.position.x + bodyB.position.x)/2, (bodyA.position.y + bodyB.position.y)/2, next.r, { label: next.label, render: { fillStyle: next.color } });
                            Composite.remove(engine.world, [bodyA, bodyB]);
                            Composite.add(engine.world, upgraded);
                        }
                    }
                });
            });

            Events.on(engine, 'afterUpdate', () => {
                if (isGameOver) return;
                Composite.allBodies(engine.world).forEach(body => {
                    if (!body.isStatic && body.position.y < 60 && body.velocity.y < 0.1 && !body.isFirstDrop) {
                        isGameOver = true;
                        document.getElementById("gameOverOverlay").style.display = "flex";
                        document.getElementById("finalScore").innerText = score;
                        let hs = parseInt(localStorage.getItem('highScore')) || 0;
                        if(score > hs) localStorage.setItem('highScore', score);
                    }
                    if(body.isFirstDrop && body.position.y > 100) body.isFirstDrop = false;
                });
            });

            Events.on(render, 'afterRender', () => {
                const ctx = render.context;
                if(!ctx) return;
                Composite.allBodies(engine.world).forEach(body => {
                    if (body.label && body.label !== 'wall') {
                        ctx.font = `${body.circleRadius * 1.4}px Arial`;
                        ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                        ctx.fillText(body.label, body.position.x, body.position.y);
                    }
                });
            });

            Render.run(render);
            runner = Runner.create();
            Runner.run(runner, engine);
        }

        // --- YILAN OYUNU MANTIƒûI ---
        const sCanvas = document.getElementById("snakeCanvas");
        const sCtx = sCanvas.getContext("2d");
        let snake, food, d, nextD, snakeScore, snakeGameLoop;
        const box = 20;

        function openSnakeGame() {
            document.getElementById("menuButtons").style.display = "none";
            document.getElementById("snakeWrapper").style.display = "block";
            document.getElementById("snakeGameOver").style.display = "none";
            resetSnake();
        }

        function closeSnakeGame() {
            clearInterval(snakeGameLoop);
            document.getElementById("snakeWrapper").style.display = "none";
            document.getElementById("menuButtons").style.display = "flex";
        }

        function resetSnake() {
            sCanvas.width = 320;
            sCanvas.height = 320;
            snake = [{x: 8 * box, y: 10 * box}, {x: 7 * box, y: 10 * box}];
            food = { x: Math.floor(Math.random() * 15) * box, y: Math.floor(Math.random() * 15) * box };
            snakeScore = 0;
            d = null; nextD = null;
            document.getElementById("snakeScore").innerText = snakeScore;
            if(snakeGameLoop) clearInterval(snakeGameLoop);
            snakeGameLoop = setInterval(drawSnake, 190);
        }

        document.addEventListener("keydown", (e) => {
            if(e.keyCode == 37 && d != "RIGHT") nextD = "LEFT";
            else if(e.keyCode == 38 && d != "DOWN") nextD = "UP";
            else if(e.keyCode == 39 && d != "LEFT") nextD = "RIGHT";
            else if(e.keyCode == 40 && d != "UP") nextD = "DOWN";
        });

        function changeDir(dir) {
            if(dir == "LEFT" && d != "RIGHT") nextD = "LEFT";
            if(dir == "UP" && d != "DOWN") nextD = "UP";
            if(dir == "RIGHT" && d != "LEFT") nextD = "RIGHT";
            if(dir == "DOWN" && d != "UP") nextD = "DOWN";
        }

        function drawSnake() {
            d = nextD;
            sCtx.fillStyle = "white";
            sCtx.fillRect(0, 0, sCanvas.width, sCanvas.height);

            for(let i = 0; i < snake.length; i++) {
                if (i === 0) {
                    sCtx.fillStyle = "black";
                    sCtx.beginPath();
                    sCtx.roundRect(snake[i].x, snake[i].y, box, box, 6);
                    sCtx.fill();
                    // G√∂zler
                    sCtx.fillStyle = "white";
                    sCtx.beginPath();
                    sCtx.arc(snake[i].x+6, snake[i].y+6, 2.5, 0, Math.PI*2);
                    sCtx.arc(snake[i].x+14, snake[i].y+6, 2.5, 0, Math.PI*2);
                    sCtx.fill();
                } else {
                    sCtx.fillStyle = "#333";
                    sCtx.beginPath();
                    sCtx.roundRect(snake[i].x+1, snake[i].y+1, box-2, box-2, 10);
                    sCtx.fill();
                }
            }

            sCtx.font = "16px Arial";
            sCtx.fillText("üçé", food.x+2, food.y+16);

            if(!d) return;

            let snakeX = snake[0].x;
            let snakeY = snake[0].y;

            if( d == "LEFT") snakeX -= box;
            if( d == "UP") snakeY -= box;
            if( d == "RIGHT") snakeX += box;
            if( d == "DOWN") snakeY += box;

            let newHead = { x: snakeX, y: snakeY };

            if(snakeX < 0 || snakeX >= sCanvas.width || snakeY < 0 || snakeY >= sCanvas.height || collision(newHead, snake)) {
                clearInterval(snakeGameLoop);
                document.getElementById("snakeGameOver").style.display = "flex";
                return;
            }

            if(snakeX == food.x && snakeY == food.y) {
                snakeScore++;
                document.getElementById("snakeScore").innerText = snakeScore;
                food = { x: Math.floor(Math.random() * 15) * box, y: Math.floor(Math.random() * 15) * box };
                playPop();
            } else {
                snake.pop();
            }
            snake.unshift(newHead);
        }

        function collision(head, array) {
            for(let i = 0; i < array.length; i++) {
                if(head.x == array[i].x && head.y == array[i].y) return true;
            }
            return false;
        }

        // Helper for rounded rect
        if (!CanvasRenderingContext2D.prototype.roundRect) {
            CanvasRenderingContext2D.prototype.roundRect = function (x, y, w, h, r) {
                if (w < 2 * r) r = w / 2; if (h < 2 * r) r = h / 2;
                this.moveTo(x + r, y); this.arcTo(x + w, y, x + w, y + h, r);
                this.arcTo(x + w, y + h, x, y + h, r); this.arcTo(x, y + h, x, y, r);
                this.arcTo(x, y, x + w, y, r); this.closePath(); return this;
            }
        }
    </script>
</body>
</html>